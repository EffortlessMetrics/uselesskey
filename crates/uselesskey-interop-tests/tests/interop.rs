//! Cross-backend interoperability tests.
//!
//! These tests verify that keys generated by uselesskey work across different
//! crypto backends. Each test signs with one library and verifies with another.

use std::sync::OnceLock;

use uselesskey_core::{Factory, Seed};

static FX: OnceLock<Factory> = OnceLock::new();

fn fx() -> &'static Factory {
    FX.get_or_init(|| {
        let seed = Seed::from_env_value("uselesskey-interop-test-seed-v1")
            .expect("test seed should always parse");
        Factory::deterministic(seed)
    })
}

/// Extract the raw public key bytes from a DER-encoded SPKI structure.
///
/// SPKI is: `SEQUENCE { SEQUENCE { algorithm }, BIT STRING { public key } }`.
/// The BIT STRING has a leading byte for unused-bits count (always 0 for
/// keys), so the raw key bytes start after that byte.
///
/// This is intentionally kept simple; it does not validate the full ASN.1
/// structure because we only feed it known-good output from uselesskey.
fn extract_public_key_from_spki(spki_der: &[u8]) -> &[u8] {
    // Walk the outer SEQUENCE tag + length
    let (_, rest) = skip_tag_and_length(spki_der);
    // Walk the inner SEQUENCE (algorithmIdentifier) tag + length
    let (inner_len, rest) = skip_tag_and_length(rest);
    let rest = &rest[inner_len..];
    // Now we should be at the BIT STRING
    assert_eq!(rest[0], 0x03, "expected BIT STRING tag");
    let (bit_string_len, rest) = skip_tag_and_length(rest);
    // First byte of BIT STRING content is unused-bits count (should be 0)
    assert_eq!(rest[0], 0x00, "expected 0 unused bits");
    &rest[1..bit_string_len]
}

/// Skip an ASN.1 tag byte and its length encoding. Returns (content_length, rest_of_slice).
fn skip_tag_and_length(data: &[u8]) -> (usize, &[u8]) {
    // skip the tag byte
    let data = &data[1..];
    if data[0] & 0x80 == 0 {
        // short form
        let len = data[0] as usize;
        (len, &data[1..])
    } else {
        // long form
        let num_bytes = (data[0] & 0x7f) as usize;
        let mut len: usize = 0;
        for i in 0..num_bytes {
            len = (len << 8) | (data[1 + i] as usize);
        }
        (len, &data[1 + num_bytes..])
    }
}

/// ECDSA P-256: sign with `p256` crate, verify with `ring`.
mod ecdsa_p256_to_ring {
    use super::*;
    use p256::ecdsa::signature::Signer;
    use p256::pkcs8::DecodePrivateKey;
    use ring::signature::{self, UnparsedPublicKey};
    use uselesskey_ecdsa::{EcdsaFactoryExt, EcdsaSpec};

    #[test]
    fn p256_sign_ring_verify() {
        let fx = fx();
        let keypair = fx.ecdsa("interop-ecdsa", EcdsaSpec::es256());

        // Sign with the p256 crate using PKCS#8 DER
        let signing_key = p256::ecdsa::SigningKey::from_pkcs8_der(keypair.private_key_pkcs8_der())
            .expect("valid P-256 PKCS#8 DER");
        let message = b"cross-backend interop test message";
        let sig: p256::ecdsa::DerSignature = signing_key.sign(message);

        // ring expects the raw uncompressed EC point bytes (0x04 || x || y),
        // not the full SPKI DER.
        let raw_pubkey = extract_public_key_from_spki(keypair.public_key_spki_der());

        let public_key = UnparsedPublicKey::new(&signature::ECDSA_P256_SHA256_ASN1, raw_pubkey);
        public_key
            .verify(message, sig.as_bytes())
            .expect("ring should verify p256-signed signature");
    }

    #[test]
    fn p256_sign_ring_verify_rejects_wrong_message() {
        let fx = fx();
        let keypair = fx.ecdsa("interop-ecdsa-tamper", EcdsaSpec::es256());

        let signing_key = p256::ecdsa::SigningKey::from_pkcs8_der(keypair.private_key_pkcs8_der())
            .expect("valid P-256 PKCS#8 DER");
        let sig: p256::ecdsa::DerSignature = signing_key.sign(b"original message");

        let raw_pubkey = extract_public_key_from_spki(keypair.public_key_spki_der());

        let public_key = UnparsedPublicKey::new(&signature::ECDSA_P256_SHA256_ASN1, raw_pubkey);
        let result = public_key.verify(b"tampered message", sig.as_bytes());
        assert!(
            result.is_err(),
            "ring should reject signature for wrong message"
        );
    }
}

/// Ed25519: sign with `ed25519-dalek`, verify with `ring`.
mod ed25519_dalek_to_ring {
    use super::*;
    use ed25519_dalek::Signer;
    use ed25519_dalek::pkcs8::DecodePrivateKey;
    use ring::signature::{self, UnparsedPublicKey};
    use uselesskey_ed25519::{Ed25519FactoryExt, Ed25519Spec};

    #[test]
    fn dalek_sign_ring_verify() {
        let fx = fx();
        let keypair = fx.ed25519("interop-ed25519", Ed25519Spec::new());

        // Sign with ed25519-dalek using PKCS#8 DER
        let signing_key =
            ed25519_dalek::SigningKey::from_pkcs8_der(keypair.private_key_pkcs8_der())
                .expect("valid Ed25519 PKCS#8 DER");
        let message = b"cross-backend ed25519 interop test";
        let sig = signing_key.sign(message);

        // ring's Ed25519 verifier takes raw 32-byte public key, NOT SPKI.
        // Extract the raw 32-byte key from the SPKI DER structure.
        let raw_public_key = extract_public_key_from_spki(keypair.public_key_spki_der());

        let public_key = UnparsedPublicKey::new(&signature::ED25519, raw_public_key);
        public_key
            .verify(message, sig.to_bytes().as_ref())
            .expect("ring should verify dalek-signed Ed25519 signature");
    }

    #[test]
    fn dalek_sign_ring_verify_rejects_wrong_message() {
        let fx = fx();
        let keypair = fx.ed25519("interop-ed25519-tamper", Ed25519Spec::new());

        let signing_key =
            ed25519_dalek::SigningKey::from_pkcs8_der(keypair.private_key_pkcs8_der())
                .expect("valid Ed25519 PKCS#8 DER");
        let sig = signing_key.sign(b"original message");

        let raw_public_key = extract_public_key_from_spki(keypair.public_key_spki_der());

        let public_key = UnparsedPublicKey::new(&signature::ED25519, raw_public_key);
        let result = public_key.verify(b"tampered message", sig.to_bytes().as_ref());
        assert!(
            result.is_err(),
            "ring should reject Ed25519 signature for wrong message"
        );
    }
}

/// RSA: sign with `rsa` crate (PKCS1v15 SHA-256), verify with `ring`.
mod rsa_rustcrypto_to_ring {
    use super::*;
    use ring::signature::{self, UnparsedPublicKey};
    use rsa::pkcs1v15::SigningKey;
    use rsa::pkcs8::DecodePrivateKey;
    use rsa::signature::SignatureEncoding;
    use rsa::signature::Signer;
    use sha2::Sha256;
    use uselesskey_rsa::{RsaFactoryExt, RsaSpec};

    #[test]
    fn rsa_crate_sign_ring_verify() {
        let fx = fx();
        let keypair = fx.rsa("interop-rsa", RsaSpec::rs256());

        // Sign with the rsa crate using PKCS#8 DER
        let private_key = rsa::RsaPrivateKey::from_pkcs8_der(keypair.private_key_pkcs8_der())
            .expect("valid RSA PKCS#8 DER");
        let signing_key = SigningKey::<Sha256>::new(private_key);
        let message = b"cross-backend RSA interop test";
        let sig = signing_key.sign(message);

        // ring expects the DER-encoded RSAPublicKey (PKCS#1 format) for RSA,
        // which is the raw content inside the SPKI BIT STRING.
        let raw_pubkey = extract_public_key_from_spki(keypair.public_key_spki_der());

        let public_key = UnparsedPublicKey::new(&signature::RSA_PKCS1_2048_8192_SHA256, raw_pubkey);
        public_key
            .verify(message, &sig.to_bytes())
            .expect("ring should verify rsa-crate-signed signature");
    }

    #[test]
    fn rsa_crate_sign_ring_verify_rejects_wrong_message() {
        let fx = fx();
        let keypair = fx.rsa("interop-rsa-tamper", RsaSpec::rs256());

        let private_key = rsa::RsaPrivateKey::from_pkcs8_der(keypair.private_key_pkcs8_der())
            .expect("valid RSA PKCS#8 DER");
        let signing_key = SigningKey::<Sha256>::new(private_key);
        let sig = signing_key.sign(b"original message");

        let raw_pubkey = extract_public_key_from_spki(keypair.public_key_spki_der());

        let public_key = UnparsedPublicKey::new(&signature::RSA_PKCS1_2048_8192_SHA256, raw_pubkey);
        let result = public_key.verify(b"tampered message", &sig.to_bytes());
        assert!(
            result.is_err(),
            "ring should reject RSA signature for wrong message"
        );
    }
}
